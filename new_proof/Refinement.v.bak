From stdpp Require Import mapset.
From stdpp Require Import natmap.
From CT Require Import CoreLangProp.
From CT Require Import OperationalSemanticsProp.
From CT Require Import BasicTypingProp.
From CT Require Import SyntaxSugar.

Import Atom.
Import CoreLang.
Import Tactics.
Import NamelessTactics.
Import OperationalSemantics.
Import OperationalSemanticsProp.
Import BasicTyping.
Import SyntaxSugar.

(* state works like vfvar *)
Definition state := amap constant.

#[global]
Instance state_stale : @Stale aset state := dom aset.
Arguments state_stale /.

(* bstate works like vfbar, which is a finite map with a bound. *)
Inductive bstate :=
| bstate_constr (bound: nat) (m: nat -> constant).

Notation " 'b{' n '}[' m ']' " := (bstate_constr n m) (at level 80, right associativity, n constr, m constr).

Definition bstate_emp: bstate := b{ 0 }[ fun _ => 0 ].

(* Definition bstate_shift (bst: bstate) : bstate := *)
(*   match bst with *)
(*   | b{ n }[ m ] => b{ S n }[ fun i => m (S i) ] *)
(*   end. *)

Definition bstate_push (c: constant) (bst: bstate) : bstate :=
  match bst with
  | b{ n }[ m ] => b{ S n }[ fun i => match i with 0 => c | S i => m i end ]
  end.

Definition bstate_find (bst: bstate) (i: nat) : option constant :=
  match bst with
  | b{ n }[ m ] => if decide (i < n) then Some (m i) else None
  end.

Notation " 'b{0}' " := bstate_emp (at level 80).
Notation " 'b<[0:=' c ']>' " := (bstate_push c) (at level 80, c constr).
Notation " m 'b!!' i " := (bstate_find m i) (at level 80, m constr, i constr).

Definition ty_of_state (st: state) : amap base_ty := ty_of_const <$> st.

Definition refinement : Type := bstate -> state -> constant -> Prop.

Inductive rty : Type :=
| BaseOver (B: base_ty) (n: nat) (d: aset) (ϕ: refinement)
| BaseUnder (B: base_ty) (n: nat) (d: aset) (ϕ: refinement)
| DependArrow (B: base_ty) (n: nat) (d: aset) (ϕ: refinement) (τ: rty)
| IndependArrow (τ1: rty) (τ2: rty).

Global Hint Constructors rty: core.

Notation "'[v:' B '|' n '|' d '|' ϕ ']'" := (BaseUnder B n d ϕ) (at level 80, B constr, ϕ constr).
Notation "'{v:' B '|' n '|' d '|' ϕ '}'" := (BaseOver B n d ϕ) (at level 80, B constr, ϕ constr).
Notation "'-:{v:' B '|' n '|' d '|' ϕ '}' '⤑' τ" := (DependArrow B n d ϕ τ) (at level 80, right associativity, B constr, ϕ constr, τ constr).
Notation " τ1 '⤑' τ2 " := (IndependArrow τ1 τ2) (at level 80, right associativity, τ1 constr, τ2 constr).

(* open *)

(* Definition refinement_open_c (k: nat) (c: constant) (ϕ: refinement) : refinement := *)
(*   fun bst st v => ϕ (<[ k := c ]> bst) st v. *)

(* Definition refinement_open_a (k: nat) (x: atom) (ϕ: refinement) : refinement := *)
(*   fun bst st v => ϕ (match st !! x with *)
(*                   | None => delete k bst *)
(*                   | Some c => <[ k := c ]> bst *)
(*                   end) st v. *)

(* Fixpoint rty_open_c (k: nat) (c: constant) (τ: rty) : rty := *)
(*   match τ with *)
(*   | {v: B | n | d | ϕ } => {v: B | n ∖ {[k]} | d | refinement_open_c k c ϕ } *)
(*   | [v: B | n | d | ϕ ] => [v: B | n ∖ {[k]} | d | refinement_open_c k c ϕ ] *)
(*   | -:{v: B | n | d | ϕ } ⤑ τ => -:{v: B | n ∖ {[k]} | d | refinement_open_c k c ϕ } ⤑ (rty_open_c (S k) c τ) *)
(*   | τ1 ⤑ τ2 => (rty_open_c k c τ1) ⤑ (rty_open_c k c τ2) *)
(*   end. *)

(* Fixpoint rty_open_a (k: nat) (a: atom) (τ: rty) : rty := *)
(*   match τ with *)
(*   | {v: B | n | d | ϕ } => {v: B | n ∖ {[k]} | {[a]} ∪ d | refinement_open_a k a ϕ } *)
(*   | [v: B | n | d | ϕ ] => [v: B | n ∖ {[k]} | {[a]} ∪ d | refinement_open_a k a ϕ ] *)
(*   | -:{v: B | n | d | ϕ } ⤑ τ => -:{v: B | n ∖ {[k]} | {[a]} ∪ d | refinement_open_a k a ϕ } ⤑ (rty_open_a (S k) a τ) *)
(*   | τ1 ⤑ τ2 => (rty_open_a k a τ1) ⤑ (rty_open_a k a τ2) *)
(*   end. *)

(* Notation "'{' k '~c>' s '}' e" := (rty_open_c k s e) (at level 20, k constr). *)
(* Notation "'{' k '~a>' s '}' e" := (rty_open_a k s e) (at level 20, k constr). *)

(* Notation "e '^c^' s" := (rty_open_c 0 s e) (at level 20). *)
(* Notation "e '^a^' s" := (rty_open_a 0 s e) (at level 20). *)

(* free variables *)

Fixpoint rty_fv τ : aset :=
  match τ with
  | {v: _ | _ | d | _ } => d
  | [v: _ | _ | d | _ ] => d
  | -:{v: _ | _ | d | _ } ⤑ τ => d ∪ (rty_fv τ)
  | τ1 ⤑ τ2 => (rty_fv τ1) ∪ (rty_fv τ2)
  end.

#[global]
Instance rty_stale : @Stale aset rty := rty_fv.
Arguments rty_stale /.

(* subst *)

Definition refinement_subst: atom -> atom -> refinement -> refinement :=
  fun x1 x2 ϕ bst st c => ϕ bst (match st !! x2 with
                              | None => delete x1 st
                              | Some c1 => <[x1 := c1]> (delete x2 st)
                              end) c.

(* Definition refinement_set_subst: atom -> atom -> aset -> aset := *)
(*   fun x1 x2 d => d ∖ {[x1]} ∪ {[x2]}. *)

Notation " '{' x '↦' y '}r' m " := (refinement_subst x y m) (at level 30).
(* Notation " '{' x '↦' y '}d' m " := (refinement_set_subst x y m) (at level 30). *)

Fixpoint rty_subst (x y: atom) (τ: rty): rty :=
  match τ with
  | {v: B | n | d | ϕ } => {v: B | n | {[y]} ∪ d | { x ↦ y }r ϕ }
  | [v: B | n | d | ϕ ] => [v: B | n | {[y]} ∪ d | { x ↦ y }r ϕ ]
  | -:{v: B | n | d | ϕ } ⤑ τ => -:{v: B | n | {[y]} ∪ d | { x ↦ y }r ϕ } ⤑ (rty_subst x y τ)
  | τ1 ⤑ τ2 => (rty_subst x y τ1) ⤑ (rty_subst x y τ2)
  end.

Notation " '{' x '↦' y '}' m " := (rty_subst x y m) (at level 30).

(* well formed, locally closed, closed with state *)

Definition not_fv_in_refinement (x: atom) (ϕ: refinement) :=
  forall (m: state), (forall bst (c v: constant), ϕ bst (<[ x := c ]> m) v <-> ϕ bst m v).

Definition bound_in_refinement (bound: nat) (ϕ: refinement) :=
  forall st (n: nat) (m: nat -> constant) v, bound <= n -> ϕ (b{n}[m]) st v <-> ϕ (b{bound}[m]) st v.

Definition wf_r (n: nat) (d: aset) (ϕ: refinement) :=
  (forall (x: atom), x ∉ d -> not_fv_in_refinement x ϕ) /\ (bound_in_refinement n ϕ).

Definition not_overbasety rty: Prop :=
  match rty with
  | BaseOver _ _ _ _ => False
  | _ => True
  end.

Inductive wf_rty: rty -> Prop :=
| wf_rty_over_base: forall B n d ϕ, wf_r n d ϕ -> wf_rty ({v: B | n | d | ϕ })
| wf_rty_under_base: forall B n d ϕ, wf_r n d ϕ -> wf_rty ([v: B | n | d | ϕ ])
| wf_rty_oarr: forall B n d ϕ (τ: rty),
    wf_r n d ϕ ->
    not_overbasety τ ->
    wf_rty τ -> wf_rty ( -:{v: B | n | d | ϕ } ⤑ τ)
| wf_rty_arrarr1: forall B n d ϕ (τ1 τ2: rty),
    wf_rty ( -:{v: B | n | d | ϕ } ⤑ τ1) ->
    not_overbasety τ2 ->
    wf_rty τ2 ->
    wf_rty (( -:{v: B | n | d | ϕ } ⤑ τ1) ⤑ τ2)
| wf_rty_arrarr2: forall (τ11 τ12 τ2: rty),
    wf_rty (τ11 ⤑ τ12) ->
    wf_rty τ2 ->
    not_overbasety τ2 ->
    wf_rty (τ11 ⤑ τ12 ⤑ τ2).

Inductive lc_rty_idx: nat -> rty -> Prop :=
| lc_rty_idx_baseover: forall B n d ϕ, lc_rty_idx n ({v: B | n | d | ϕ })
| lc_rty_idx_underover: forall B n d ϕ, lc_rty_idx n ([v: B | n | d | ϕ ])
| lc_rty_idx_oarr: forall B n d ϕ τ (L: aset),
    lc_rty_idx (S n) τ ->
    lc_rty_idx n (-:{v: B | n | d | ϕ } ⤑ τ)
| lc_rty_idx_arrarr: forall n τ1 τ2, lc_rty_idx n τ1 -> lc_rty_idx n τ2 -> lc_rty_idx n (τ1 ⤑ τ2).

Definition 

Inductive lc_rty: rty -> Prop :=
| lc_rty_baseover: forall B d ϕ, lc_rty ({v: B | 0 | d | ϕ })
| lc_rty_underover: forall B d ϕ, lc_rty ([v: B | 0 | d | ϕ ])
| lc_rty_oarr: forall B d ϕ τ (L: aset),
    (forall (x: atom), x ∉ L -> lc_rty (τ ^a^ x)) ->
    lc_rty (-:{v: B | ∅ | d | ϕ } ⤑ τ)
| lc_rty_arrarr: forall τ1 τ2, lc_rty τ1 -> lc_rty τ2 -> lc_rty (τ1 ⤑ τ2).

Definition rty_body (τ: rty) := exists (L: aset), forall (x: atom), x ∉ L -> lc_rty (τ ^a^ x).

(* Erase *)

Fixpoint rty_erase ut : ty :=
  match ut with
  | ({v: T | _ | _ | _ }) => T
  | [v: T | _ | _ | _ ] => T
  | -:{v: T1 | _ | _ | _ } ⤑ retty => T1 ⤍ (rty_erase retty)
  | t1 ⤑ t2 => (rty_erase t1) ⤍ (rty_erase t2)
  end.

Notation " '⌊' ty '⌋' " := (rty_erase ty) (at level 30).

(* Denotation: *)

Definition closed_rty (st: state) (τ: rty) := wf_rty τ /\ lc_rty τ /\ (rty_fv τ) ⊆ (dom _ st).

Fixpoint rR (bst: state) (st: state) (τ: rty) (e: tm) : Prop :=
  [] ⊢t e ⋮t ⌊ τ ⌋ /\ closed_rty st τ /\
    (match τ with
     | {v: B | _ | _ | ϕ} => exists (c: constant), [] ⊢t c ⋮v B /\ ϕ bst st c /\ e = c
     | [v: B | _ | _ | ϕ] => forall (c: constant), [] ⊢t c ⋮v B -> ϕ bst st c -> e ↪* c
     | -:{v: B | _ | _ | ϕ } ⤑ τ =>
         forall (c_x: constant), [] ⊢t c_x ⋮v B -> ϕ bst st c_x -> rR st (<[]> bst) (τ ^c^ c_x) (mk_app e c_x)
     | τ1 ⤑ τ2 => forall (e_x: tm), rR st τ1 e_x -> rR st τ2 (mk_app e e_x)
     end).

Notation " '{' st '}⟦' τ '⟧' " := (rR st τ) (at level 30).



Definition refinement_set_substid: atom -> atom -> aset -> aset :=
fun x1 x2 d => d ∖ {[x1]} ∪ {[x2]}.


(* Definition over_to_under ot := *)
(*   match ot with *)
(*   | BaseOver t d ϕ => BaseUnder t d ϕ *)
(*   end. *)

(* Definition z := [v: TNat | ∅ | fun _ _ => True ]. *)
(* Definition y := {v: TNat | ∅ | fun _ _ => True }. *)
(* Definition aa (x: atom) := x:{v: TNat | ∅ | fun _ _ => True } ⤑ z. *)
(* Definition bb (x: atom) := (z ⤑ z). *)

(* Inductive rty : Type := *)
(* | Uty: underty -> rty *)
(* | Oty: overbasety -> rty. *)

(* Global Hint Constructors rty: core. *)

(* Coercion Uty : underty >-> rty. *)
(* Coercion Oty : overbasety >-> rty. *)

Inductive wf_rty: rty -> Prop :=
| wf_rty_over_base: forall B d ϕ, wf_r d ϕ -> wf_rty ({v: B | d | ϕ })
| wf_rty_under_base: forall B d ϕ, wf_r d ϕ -> wf_rty ([v: B | d | ϕ ])
| wf_rty_oarr: forall x B d ϕ (τ: rty),
    wf_r d ϕ ->
    not_overbasety τ ->
    wf_rty τ -> wf_rty (x:{v: B | d | ϕ } ⤑ τ)
| wf_rty_arrarr1: forall x B d ϕ (τ1 τ2: rty),
    wf_rty (x:{v: B | d | ϕ } ⤑ τ1) ->
    not_overbasety τ2 ->
    wf_rty τ2 ->
    wf_rty ((x:{v: B | d | ϕ } ⤑ τ1) ⤑ τ2)
| wf_rty_arrarr2: forall (τ11 τ12 τ2: rty),
    wf_rty (τ11 ⤑ τ12) ->
    wf_rty τ2 ->
    not_overbasety τ2 ->
    wf_rty (τ11 ⤑ τ12 ⤑ τ2).

Global Hint Constructors wf_rty: core.

Definition mk_eq_constant c := [v: ty_of_const c | ∅ | fun _ v => v = c ].
Definition mk_under_bot ty := [v: ty | ∅ | fun _ _ => False ].
Definition mk_under_top ty := [v: ty | ∅ | fun _ _ => True ].
Definition mk_over_top ty := {v: ty | ∅ | fun _ _ => True }.
Definition mk_eq_var ty (x: atom) := [v: ty | {[x]} | fun st v => Some v = st !! x ].
Definition mk_op_ret op a b :=
  [v: ret_ty_of_op op | {[a;b]} | fun st v => exists c_a c_b, st !! a = Some c_a /\ st !! b = Some c_b /\ eval_op op c_a c_b v ].
Definition mk_op op a b :=
  a:{v: fst_ty_of_op op | ∅ | fun _ _ => True } ⤑ b:{v: snd_ty_of_op op | ∅ | fun _ _ => True } ⤑ mk_op_ret op a b.

Ltac wf_r_solver :=
match goal with
  | [|- wf_r _ _ ] => unfold wf_r; unfold not_fv_in_refinement; intros; auto
  end.

Lemma wf_rty_mk_eq_constant: forall c, wf_rty (mk_eq_constant c).
Proof.
  intros. constructor. wf_r_solver.
Qed.

Lemma wf_rty_mk_under_bot: forall B, wf_rty (mk_under_bot B).
Proof.
  intros. constructor. wf_r_solver.
Qed.

Lemma wf_rty_mk_under_top: forall B, wf_rty (mk_under_top B).
Proof.
  intros. constructor. wf_r_solver.
Qed.

Lemma wf_rty_mk_over_top: forall B, wf_rty (mk_over_top B).
Proof.
  intros. constructor. wf_r_solver.
Qed.

Ltac my_simplify_map_eq :=
  repeat (
      match goal with
      | [|- Some ?x = Some ?y] => assert (x = y); auto
      | [|- (?a = ?b) <-> (?a = ?c)] => assert (b = c) as Htmp; try rewrite Htmp; auto
      | [|- (?a = ?b) = (?a = ?c)] => assert (b = c) as Htmp; try rewrite Htmp; auto
      | [|- <[_:=_]> ?m !! ?x = ?m !! ?x] => setoid_rewrite lookup_insert_ne; simplify_map_eq; auto
      | [|- <[_:=_]> ?m !! ?x = Some _ ] => setoid_rewrite lookup_insert_ne; simplify_map_eq; auto
      | [H: <[_:=_]> ?m !! ?x = Some _ |- ?m !! ?x = Some _] => setoid_rewrite lookup_insert_ne in H; auto; fast_set_solver
      end || simplify_map_eq || fast_set_solver).

Lemma wf_rty_mk_eq_var: forall B x, wf_rty (mk_eq_var B x).
Proof.
  intros. constructor. wf_r_solver. my_simplify_map_eq.
Qed.

Lemma wf_rty_mk_op_ret: forall op a b, wf_rty (mk_op_ret op a b).
Proof.
  intros. constructor. wf_r_solver.
  split; intros; mydestr.
  - repeat eexists; repeat split; my_simplify_map_eq.
  - repeat eexists; repeat split; my_simplify_map_eq.
Qed.

Lemma wf_rty_mk_op: forall op a b, wf_rty (mk_op op a b).
Proof.
  intros. constructor; simpl; auto.
  - wf_r_solver.
  - constructor; simpl; auto.
    wf_r_solver. apply wf_rty_mk_op_ret.
Qed.

(* Free variables *)

Fixpoint rty_fv τ : aset :=
  match τ with
  | ({v: _ | d | _ }) => d
  | [v: _ | d | _ ] => d
  | _ :{v: _ | d | _ } ⤑ retty => d ∪ (rty_fv retty)
  | t1 ⤑ t2 => (rty_fv t1) ∪ (rty_fv t2)
  end.

(* #[global] *)
(* Instance overbasety_stale : @Stale aset overbasety := overbasety_fv. *)
(* Arguments overbasety_stale /. *)
(* #[global] *)
(* Instance underty_stale : @Stale aset underty := underty_fv. *)
(* Arguments underty_stale /. *)
#[global]
Instance rty_stale : @Stale aset rty := rty_fv.
Arguments rty_stale /.

(* Erase *)

Fixpoint rty_erase ut : ty :=
  match ut with
  | ({v: T | _ | _ }) => T
  | [v: T | _ | _ ] => T
  | _ :{v: T1 | _ | _ } ⤑ retty => T1 ⤍ (rty_erase retty)
  | t1 ⤑ t2 => (rty_erase t1) ⤍ (rty_erase t2)
  end.

Notation " '⌊' ty '⌋' " := (rty_erase ty) (at level 30).

(* Inductive eval_cid: state -> cid -> constant -> Prop := *)
(* | eval_cid_const: forall st c, eval_cid st (vconst c) c *)
(* | eval_cid_id: forall st id c, st id = Some c -> eval_cid st (vvar id) c. *)

(* Definition mk_op_retty_from_cids (op: biop) (cid1 cid2: cid): underty := *)
(*   BaseUnder (ret_ty_of_op op) (fun st c => *)
(*                                  (exists (c1 c2: constant), *)
(*                                      eval_cid st cid1 c1 /\ eval_cid st cid2 c2 /\ eval_op op c1 c2 c *)
(*                                  )). *)

(* subst id *)

Definition refinement_substid: atom -> atom -> refinement -> refinement :=
  fun x1 x2 ϕ st c => ϕ (match st !! x2 with
                      | None => delete x1 st
                      | Some c1 => <[x1 := c1]> (delete x2 st)
                      end) c.

Definition refinement_set_substid: atom -> atom -> aset -> aset :=
fun x1 x2 d => d ∖ {[x1]} ∪ {[x2]}.

Notation " '{' x '↦a' y '}r' m " := (refinement_substid x y m) (at level 30).
Notation " '{' x '↦a' y '}d' m " := (refinement_set_substid x y m) (at level 30).

Lemma same_state_cause_same_rresult: forall (ϕ: refinement) v st1 st2, st1 = st2 -> ϕ st1 v <-> ϕ st2 v.
Proof. intros; subst; split; auto. Qed.

Lemma substid_perserver_wf_r: forall (x: atom) d ϕ, wf_r d ϕ -> (forall y, wf_r ({ x ↦a y }d d) ({ x ↦a y }r ϕ)).
Proof.
  unfold wf_r; unfold not_fv_in_refinement; intros.
  - unfold refinement_substid. unfold refinement_set_substid in H0.
    setoid_rewrite lookup_insert_ne; try fast_set_solver.
    destruct (atom_dec x0 x); subst.
    + apply same_state_cause_same_rresult.
      destruct (m !! y) eqn: Hz.
      setoid_rewrite Hz.
      setoid_rewrite delete_insert_ne; try fast_set_solver.
      setoid_rewrite insert_insert; try fast_set_solver.
      setoid_rewrite Hz.
      setoid_rewrite delete_insert_delete; auto.
    + destruct (m !! y) eqn: Hz.
      setoid_rewrite Hz.
      setoid_rewrite delete_insert_ne; try fast_set_solver.
      setoid_rewrite insert_commute; try fast_set_solver.
      rewrite (H x0); try fast_set_solver.
      setoid_rewrite Hz.
      setoid_rewrite delete_insert_ne; try fast_set_solver.
      rewrite (H x0); try fast_set_solver.
Qed.

Fixpoint rty_subst_id (x y: atom) (uty: rty): rty :=
  match uty with
  | {v: B | d | ϕ} => {v: B | { x ↦a y }d d | { x ↦a y }r ϕ}
  | [v: B | d | ϕ] => [v: B | { x ↦a y }d d | { x ↦a y }r ϕ]
  | a :{v: B | d | ϕ } ⤑ τ =>
      if decide (a = x) then
        a :{v: B | { x ↦a y }d d | { x ↦a y }r ϕ} ⤑ τ
      else
        a :{v: B | { x ↦a y }d d | { x ↦a y }r ϕ} ⤑ (rty_subst_id x y τ)
  | t1 ⤑ t2 => (rty_subst_id x y t1) ⤑ (rty_subst_id x y t2)
  end.

Notation " '{' x '↦a' y '}' m " := (rty_subst_id x y m) (at level 30).

(* subst constant *)

Definition refinement_substc: atom -> constant -> refinement -> refinement :=
  fun x1 c2 ϕ st c => ϕ (<[x1 := c2]> st) c.

Notation " '{' x '↦c' y '}r' m " := (refinement_substc x y m) (at level 30).

Lemma substc_perserver_wf_r: forall (x: atom) d ϕ, wf_r d ϕ -> (forall c, wf_r d ({ x ↦c c }r ϕ)).
Proof.
  unfold wf_r; unfold not_fv_in_refinement; intros.
  - unfold refinement_substc.
    destruct (atom_dec x0 x); subst.
    + apply same_state_cause_same_rresult.
      setoid_rewrite insert_insert; try fast_set_solver.
    + setoid_rewrite insert_commute; try fast_set_solver.
      rewrite (H x0); try fast_set_solver.
Qed.

Fixpoint rty_subst_c (x: atom) (c: constant) (uty: rty): rty :=
  match uty with
  | {v: B | d | ϕ} => {v: B | d | { x ↦c c }r ϕ}
  | [v: B | d | ϕ] => [v: B | d | { x ↦c c }r ϕ]
  | a :{v: B | d | ϕ } ⤑ τ =>
      a :{v: B | d | { x ↦c c }r ϕ} ⤑ (if decide (a = x) then τ else (rty_subst_c x c τ))
  | t1 ⤑ t2 => (rty_subst_c x c t1) ⤑ (rty_subst_c x c t2)
  end.

Notation " '{' x '↦c' y '}' m " := (rty_subst_c x y m) (at level 30).

Lemma substc_perserve_not_overbasety: forall x c τ, not_overbasety τ -> not_overbasety ({x ↦c c} τ).
Proof.
  intros. destruct τ; simpl; auto.
Qed.

Lemma substc_perserve_wf_rty: forall x c τ, wf_rty τ -> wf_rty ({x ↦c c} τ).
Proof with eauto.
  intros. induction H; simpl.
  - constructor; apply substc_perserver_wf_r; auto.
  - constructor; apply substc_perserver_wf_r; auto.
  - var_dec_solver; constructor; simpl; auto;
      try apply substc_perserve_not_overbasety; auto;
      try apply substc_perserver_wf_r; auto.
  - simpl in IHwf_rty1. repeat var_dec_solver; constructor; simpl; auto; try apply substc_perserve_not_overbasety; auto.
  - constructor; auto; try apply substc_perserve_not_overbasety; auto.
Qed.

Lemma substc_perserve_erase: forall x c τ, ⌊ {x ↦c c} τ ⌋ = ⌊ τ ⌋.
Proof.
  intros. induction τ; simpl; auto.
  - var_dec_solver. rewrite IHτ; auto.
  - rewrite IHτ1; auto. rewrite IHτ2; auto.
Qed.

(* \S{Ty}: *)
