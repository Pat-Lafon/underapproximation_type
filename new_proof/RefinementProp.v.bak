From stdpp Require Import mapset.
From stdpp Require Import natmap.
From CT Require Import CoreLangProp.
From CT Require Import OperationalSemanticsProp.
From CT Require Import BasicTypingProp.
From CT Require Import SyntaxSugar.
From CT Require Import Refinement.

Import Atom.
Import CoreLang.
Import Tactics.
Import NamelessTactics.
Import ListCtx.
Import OperationalSemantics.
Import OperationalSemanticsProp.
Import BasicTyping.
Import SyntaxSugar.
Import Refinement.

Ltac wf_rty_solver :=
match goal with
  | [|- wf_r _ _ ] => unfold wf_r; unfold not_fv_in_refinement; intros; auto
  end.

Ltac my_simplify_map_eq :=
  repeat (
      match goal with
      | [|- Some ?x = Some ?y] => assert (x = y); auto
      | [|- (?a = ?b) <-> (?a = ?c)] => assert (b = c) as Htmp; try rewrite Htmp; auto
      | [|- (?a = ?b) = (?a = ?c)] => assert (b = c) as Htmp; try rewrite Htmp; auto
      | [|- <[_:=_]> ?m !! ?x = ?m !! ?x] => setoid_rewrite lookup_insert_ne; simplify_map_eq; auto
      | [|- <[_:=_]> ?m !! ?x = Some _ ] => setoid_rewrite lookup_insert_ne; simplify_map_eq; auto
      | [|- Some _ = <[_:=_]> ?m !! ?x ] => setoid_rewrite lookup_insert_ne; simplify_map_eq; auto
      | [H: <[_:=_]> ?m !! ?x = Some _ |- ?m !! ?x = Some _] => setoid_rewrite lookup_insert_ne in H; auto; fast_set_solver
      | [H: Some _ = <[_:=_]> ?m !! ?x |- Some _ = ?m !! ?x ] => setoid_rewrite lookup_insert_ne in H; auto; fast_set_solver
      end || simplify_map_eq || fast_set_solver).

Lemma wf_rty_mk_eq_constant: forall c, wf_rty 0 ∅ (mk_eq_constant c).
Proof.
  intros. repeat constructor; auto.
Qed.

Lemma wf_rty_mk_under_bot: forall B, wf_rty 0 ∅ (mk_under_bot B).
Proof.
  intros. repeat constructor; auto.
Qed.

Lemma wf_rty_mk_under_top: forall B, wf_rty 0 ∅ (mk_under_top B).
Proof.
  intros. repeat constructor; auto.
Qed.

Lemma wf_rty_mk_over_top: forall B, wf_rty 0 ∅ (mk_over_top B).
Proof.
  intros. repeat constructor; auto.
Qed.

Lemma wf_rty_mk_eq_var: forall B x, wf_rty 0 {[x]} (mk_eq_var B x).
Proof.
  intros. repeat constructor; intros; auto; try my_simplify_map_eq.
Qed.

Ltac var_dec_solver :=
  try auto_exfalso;
  match goal with
  | [H: Some ?a = Some ?b |- _] => inversion H; subst; clear H; simpl; auto
  | [H: ?a <> ?a |- _ ] => exfalso; lia
  | [ |- Some _ = None ] => exfalso; lia
  | [ |- None = Some _ ] => exfalso; lia
  | [H: context [ decide (?a = ?a) ] |- _ ] => rw_decide_true_in a a H; auto
  | [H: context [ decide (?a = ?b) ] |- _ ] =>
      match goal with
      | [H': a = b |- _ ] => rw_decide_true_in a b H; auto
      | [H': a <> b |- _ ] => rewrite (decide_False _ _ H') in H; auto
      | _ => destruct (Nat.eq_dec a b); subst; simpl in H; simpl
      | _ => destruct (Atom.atom_dec a b); subst; simpl in H; simpl
      end
  | [H: context [ decide (?a < ?b) ] |- _ ] =>
      match goal with
      | [H': a < b |- _ ] => rewrite (decide_True _ _ H') in H; auto
      | [H': ~ (a < b) |- _ ] => rewrite (decide_False _ _ H') in H; auto
      | _ => destruct (nat_lt_dec a b); subst; simpl in H; simpl
      end
  | [ |- context [ decide (?a = ?a) ] ] => rw_decide_true a a; auto
  | [ |- context [ decide (?a = ?b) ] ] =>
      match goal with
      | [H: a = b |- _ ] => rewrite (decide_True _ _ H); auto
      | [H: a <> b |- _ ] => rewrite (decide_False _ _ H); auto
      | _ => destruct (Nat.eq_dec a b); subst; simpl; var_dec_solver
      | _ => destruct (Atom.atom_dec a b); subst; simpl; var_dec_solver
      end
  | [ |- context [ decide (?a < ?b) ] ] =>
      match goal with
      | [H': a < b |- _ ] => rewrite (decide_True _ _ H'); auto
      | [H': ~ (a < b) |- _ ] => rewrite (decide_False _ _ H'); auto
      | _ => destruct (nat_lt_dec a b); subst; simpl; simpl; var_dec_solver
      end
  | _ => progress simpl
  end.

Lemma wf_rty_mk_op_ret: forall op, wf_rty 2 ∅ (mk_op_ret op).
Proof.
  intros. repeat constructor; intros; auto; mydestr.
  - repeat eexists; repeat split; my_simplify_map_eq.
    repeat var_dec_solver.
  - repeat eexists; repeat split; my_simplify_map_eq.
    repeat var_dec_solver.
Qed.

Lemma wf_rty_mk_op: forall op, wf_rty 0 ∅ (mk_op op).
Proof.
  intros.
  destruct (wf_rty_mk_op_ret op); mydestr.
  repeat (constructor; intros; auto).
Qed.

(* Lemma same_state_cause_same_rresult: forall (ϕ: refinement) v st1 st2, st1 = st2 -> ϕ st1 v <-> ϕ st2 v. *)
(* Proof. intros; subst; split; auto. Qed. *)

Lemma substid_perserver_wf_r: forall (x: atom) d ϕ, wf_r d ϕ -> (forall y, wf_r ({ x ↦a y }d d) ({ x ↦a y }r ϕ)).
Proof.
  unfold wf_r; unfold not_fv_in_refinement; intros.
  - unfold refinement_substid. unfold refinement_set_substid in H0.
    setoid_rewrite lookup_insert_ne; try fast_set_solver.
    destruct (atom_dec x0 x); subst.
    + apply same_state_cause_same_rresult.
      destruct (m !! y) eqn: Hz.
      setoid_rewrite Hz.
      setoid_rewrite delete_insert_ne; try fast_set_solver.
      setoid_rewrite insert_insert; try fast_set_solver.
      setoid_rewrite Hz.
      setoid_rewrite delete_insert_delete; auto.
    + destruct (m !! y) eqn: Hz.
      setoid_rewrite Hz.
      setoid_rewrite delete_insert_ne; try fast_set_solver.
      setoid_rewrite insert_commute; try fast_set_solver.
      rewrite (H x0); try fast_set_solver.
      setoid_rewrite Hz.
      setoid_rewrite delete_insert_ne; try fast_set_solver.
      rewrite (H x0); try fast_set_solver.
Qed.

Fixpoint rty_subst_id (x y: atom) (uty: rty): rty :=
  match uty with
  | {v: B | d | ϕ} => {v: B | { x ↦a y }d d | { x ↦a y }r ϕ}
  | [v: B | d | ϕ] => [v: B | { x ↦a y }d d | { x ↦a y }r ϕ]
  | a :{v: B | d | ϕ } ⤑ τ =>
      if decide (a = x) then
        a :{v: B | { x ↦a y }d d | { x ↦a y }r ϕ} ⤑ τ
      else
        a :{v: B | { x ↦a y }d d | { x ↦a y }r ϕ} ⤑ (rty_subst_id x y τ)
  | t1 ⤑ t2 => (rty_subst_id x y t1) ⤑ (rty_subst_id x y t2)
  end.

Notation " '{' x '↦a' y '}' m " := (rty_subst_id x y m) (at level 30).

(* subst constant *)

Definition refinement_substc: atom -> constant -> refinement -> refinement :=
  fun x1 c2 ϕ st c => ϕ (<[x1 := c2]> st) c.

Notation " '{' x '↦c' y '}r' m " := (refinement_substc x y m) (at level 30).

Lemma substc_perserver_wf_r: forall (x: atom) d ϕ, wf_r d ϕ -> (forall c, wf_r d ({ x ↦c c }r ϕ)).
Proof.
  unfold wf_r; unfold not_fv_in_refinement; intros.
  - unfold refinement_substc.
    destruct (atom_dec x0 x); subst.
    + apply same_state_cause_same_rresult.
      setoid_rewrite insert_insert; try fast_set_solver.
    + setoid_rewrite insert_commute; try fast_set_solver.
      rewrite (H x0); try fast_set_solver.
Qed.

Fixpoint rty_subst_c (x: atom) (c: constant) (uty: rty): rty :=
  match uty with
  | {v: B | d | ϕ} => {v: B | d | { x ↦c c }r ϕ}
  | [v: B | d | ϕ] => [v: B | d | { x ↦c c }r ϕ]
  | a :{v: B | d | ϕ } ⤑ τ =>
      a :{v: B | d | { x ↦c c }r ϕ} ⤑ (if decide (a = x) then τ else (rty_subst_c x c τ))
  | t1 ⤑ t2 => (rty_subst_c x c t1) ⤑ (rty_subst_c x c t2)
  end.

Notation " '{' x '↦c' y '}' m " := (rty_subst_c x y m) (at level 30).

Lemma substc_perserve_not_overbasety: forall x c τ, not_overbasety τ -> not_overbasety ({x ↦c c} τ).
Proof.
  intros. destruct τ; simpl; auto.
Qed.

Lemma substc_perserve_wf_rty: forall x c τ, wf_rty τ -> wf_rty ({x ↦c c} τ).
Proof with eauto.
  intros. induction H; simpl.
  - constructor; apply substc_perserver_wf_r; auto.
  - constructor; apply substc_perserver_wf_r; auto.
  - var_dec_solver; constructor; simpl; auto;
      try apply substc_perserve_not_overbasety; auto;
      try apply substc_perserver_wf_r; auto.
  - simpl in IHwf_rty1. repeat var_dec_solver; constructor; simpl; auto; try apply substc_perserve_not_overbasety; auto.
  - constructor; auto; try apply substc_perserve_not_overbasety; auto.
Qed.

Lemma substc_perserve_erase: forall x c τ, ⌊ {x ↦c c} τ ⌋ = ⌊ τ ⌋.
Proof.
  intros. induction τ; simpl; auto.
  - var_dec_solver. rewrite IHτ; auto.
  - rewrite IHτ1; auto. rewrite IHτ2; auto.
Qed.

(* \S{Ty}: *)
